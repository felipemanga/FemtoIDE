namespace Buttons {
    inline uint32_t buttons_state = 0;
    inline uint32_t buttons_held = 0;
}

namespace Display {
    inline uint32_t directcolor = 0xFFFF;
    inline uint32_t directbgcolor = 0x0000;
    inline int cursorX = 0;
    inline int cursorY = 0;
    inline int adjustCharStep = 1;
    inline int adjustLineStep = 1;
    inline const int fontSize = 1;
    
    inline void setCursor(int x, int y){
        cursorX = x;
        cursorY = y;
    }

//Font Generated by MikroElektronika GLCD Font Creator 1.2.0.0
//MikroElektronika 2011
//http://www.mikroe.com
//GLCD FontName : koubit
//GLCD FontSize : 7 x 7
inline const unsigned char font[] = {
        7,7,32,1,
        0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char
        0x02, 0x2E, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char !
        0x03, 0x0E, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00,  // Code for char "
        0x05, 0x14, 0x3E, 0x14, 0x3E, 0x14, 0x00, 0x00,  // Code for char #
        0x06, 0x00, 0x2E, 0x2A, 0x3E, 0x2A, 0x3A, 0x00,  // Code for char $
        0x05, 0x0C, 0x2C, 0x18, 0x34, 0x30, 0x00, 0x00,  // Code for char %
        0x06, 0x30, 0x4C, 0x4A, 0x7C, 0x30, 0x68, 0x00,  // Code for char &
        0x02, 0x0E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char '
        0x02, 0x1C, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char (
        0x02, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char )
        0x06, 0x22, 0x14, 0x3E, 0x3E, 0x14, 0x22, 0x00,  // Code for char *
        0x06, 0x08, 0x08, 0x3E, 0x3E, 0x08, 0x08, 0x00,  // Code for char +
        0x02, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char ,
        0x03, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,  // Code for char -
        0x02, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char .
        0x06, 0x20, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00,  // Code for char /
        0x06, 0x3E, 0x3E, 0x22, 0x22, 0x3E, 0x3E, 0x00,  // Code for char 0
        0x06, 0x22, 0x22, 0x3E, 0x3E, 0x20, 0x20, 0x00,  // Code for char 1
        0x06, 0x3A, 0x3A, 0x2A, 0x2A, 0x2E, 0x2E, 0x00,  // Code for char 2
        0x06, 0x2A, 0x2A, 0x2A, 0x2A, 0x3E, 0x3E, 0x00,  // Code for char 3
        0x06, 0x0E, 0x0E, 0x08, 0x08, 0x3E, 0x3E, 0x00,  // Code for char 4
        0x06, 0x2E, 0x2E, 0x2A, 0x2A, 0x3A, 0x3A, 0x00,  // Code for char 5
        0x06, 0x3E, 0x3E, 0x2A, 0x2A, 0x3A, 0x3A, 0x00,  // Code for char 6
        0x06, 0x02, 0x02, 0x02, 0x02, 0x3E, 0x3E, 0x00,  // Code for char 7
        0x06, 0x3E, 0x3E, 0x2A, 0x2A, 0x3E, 0x3E, 0x00,  // Code for char 8
        0x06, 0x2E, 0x2E, 0x2A, 0x2A, 0x3E, 0x3E, 0x00,  // Code for char 9
        0x02, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char :
        0x02, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char ;
        0x04, 0x08, 0x1C, 0x36, 0x22, 0x00, 0x00, 0x00,  // Code for char <
        0x05, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00,  // Code for char =
        0x04, 0x22, 0x36, 0x1C, 0x08, 0x00, 0x00, 0x00,  // Code for char >
        0x06, 0x02, 0x02, 0x2A, 0x2E, 0x0E, 0x04, 0x00,  // Code for char ?
        0x07, 0x7F, 0x41, 0x5D, 0x55, 0x5D, 0x11, 0x1F,  // Code for char @
        0x05, 0x3E, 0x3E, 0x0A, 0x3E, 0x3E, 0x00, 0x00,  // Code for char A
        0x05, 0x3E, 0x3E, 0x2A, 0x3E, 0x36, 0x00, 0x00,  // Code for char B
        0x05, 0x3E, 0x3E, 0x22, 0x36, 0x36, 0x00, 0x00,  // Code for char C
        0x05, 0x3E, 0x3E, 0x22, 0x3E, 0x3C, 0x00, 0x00,  // Code for char D
        0x05, 0x3E, 0x3E, 0x2A, 0x2A, 0x2A, 0x00, 0x00,  // Code for char E
        0x05, 0x3E, 0x3E, 0x0A, 0x0A, 0x02, 0x00, 0x00,  // Code for char F
        0x06, 0x3E, 0x3E, 0x22, 0x2A, 0x3A, 0x3A, 0x00,  // Code for char G
        0x06, 0x3E, 0x3E, 0x08, 0x08, 0x3E, 0x3E, 0x00,  // Code for char H
        0x02, 0x3E, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char I
        0x05, 0x30, 0x30, 0x20, 0x3E, 0x3E, 0x00, 0x00,  // Code for char J
        0x06, 0x3E, 0x3E, 0x08, 0x1C, 0x36, 0x22, 0x00,  // Code for char K
        0x05, 0x3E, 0x3E, 0x20, 0x20, 0x20, 0x00, 0x00,  // Code for char L
        0x07, 0x3E, 0x3E, 0x0C, 0x18, 0x0C, 0x3E, 0x3E,  // Code for char M
        0x06, 0x3E, 0x3E, 0x0C, 0x18, 0x3E, 0x3E, 0x00,  // Code for char N
        0x05, 0x3E, 0x3E, 0x22, 0x3E, 0x3E, 0x00, 0x00,  // Code for char O
        0x05, 0x3E, 0x3E, 0x0A, 0x0E, 0x0E, 0x00, 0x00,  // Code for char P
        0x06, 0x3E, 0x3E, 0x22, 0x22, 0x7E, 0x5E, 0x00,  // Code for char Q
        0x05, 0x3E, 0x3E, 0x1A, 0x3E, 0x2E, 0x00, 0x00,  // Code for char R
        0x05, 0x2E, 0x2E, 0x2A, 0x3A, 0x3A, 0x00, 0x00,  // Code for char S
        0x06, 0x02, 0x02, 0x3E, 0x3E, 0x02, 0x02, 0x00,  // Code for char T
        0x06, 0x3E, 0x3E, 0x20, 0x20, 0x3E, 0x3E, 0x00,  // Code for char U
        0x06, 0x1E, 0x3E, 0x30, 0x38, 0x1E, 0x0E, 0x00,  // Code for char V
        0x07, 0x3E, 0x3E, 0x30, 0x3E, 0x30, 0x3E, 0x3E,  // Code for char W
        0x06, 0x22, 0x36, 0x1C, 0x1C, 0x36, 0x22, 0x00,  // Code for char X
        0x06, 0x02, 0x06, 0x3C, 0x3C, 0x06, 0x02, 0x00,  // Code for char Y
        0x06, 0x22, 0x32, 0x3A, 0x2E, 0x26, 0x22, 0x00,  // Code for char Z
        0x02, 0x3E, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char [
        0x06, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x20, 0x00,  // Code for char BackSlash
        0x02, 0x22, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00   // Code for char ]
        };

    
    int drawChar(int x, int y, const unsigned char *bitmap, unsigned int index){
        uint8_t w = *bitmap;
        uint8_t h = *(bitmap + 1);
        uint8_t hbytes=0, xtra=1;
        if (h==8 || h==16) xtra=0; //don't add if exactly on byte limit
        hbytes=(h>>3)+xtra; //GLCD fonts are arranged w+1 times h/8 bytes
        //bitmap = bitmap + 3 + index * h * ((w>>3)+xtra); //add an offset to the pointer (fonts !)
        bitmap = bitmap + 4 + index * (w * hbytes + 1); //add an offset to the pointer (fonts !)
        //int8_t i, j, byteNum, bitNum, byteWidth = (w + 7) >> 3;
        int8_t i, j, numBytes;
        numBytes = *bitmap++; //first byte of char is the width in bytes
        // GLCD fonts are arranged LSB = topmost pixel of char, so its easy to just shift through the column
        uint16_t bitcolumn; //16 bits for 2x8 bit high characters
    
        for (i = 0; i < numBytes; i++) {
        	bitcolumn = *bitmap++;
        	if (hbytes == 2) bitcolumn |= (*bitmap++)<<8; // add second byte for 16 bit high fonts
        	
        	for (j = 0; j < h; j++) {
        	    if (bitcolumn&0x1) {
        		    DIRECT::setPixel(x + i, y + j, directcolor);
        	    } 
        	    bitcolumn>>=1;
        	}
        }
        return numBytes + adjustCharStep; // for character stepping
    }
    
    int print_char(unsigned char x, unsigned char y, unsigned char c) {
        if( font[3] && c >= 'a' && c <= 'z')
    	c &= 0xdf;
        c -= font[2];
        return drawChar(x,y,font,c);
    }

}

namespace Core {
    inline uint32_t frameCount = 0;
    inline volatile uint32_t time = 0;
    
    inline void wait(int remain){
        uint32_t start = time;
        while(time - start < remain);
    }
    
    inline void begin(){
        enableSysTick();
        DIRECT::write_command(0x03); // Entry mode... lets try if this affects the direction
        DIRECT::write_data(0x1030); // originally 0x1030 1000000110000 BGR,ID1,ID0
    }
}

extern "C" {
    void SysTick_Handler(){
        Core::time += 10;
    }
}

enum Constants {
    COLOR_BLACK = 0,
    ABIT,
    BBIT,
    CBIT,
    DOWNBIT,
    LEFTBIT,
    RIGHTBIT,
    UPBIT,
    POK_LCD_W = 220,
    POK_LCD_H = 176,
    COLOR_WHITE = 0xFFFF
};